#!/grammars/pseudo-typescript parse

INPUT: specs_file: string, session_state: SessionState

# Initialize development context
dev_agent = spawn_subagent("development", {
  context_limit: 200000,
  specs: load_specs(specs_file),
  current_step: session_state.step || 1
})

# Enhanced 9-Step Cycle
FOR step IN [session_state.step || 1..9] DO
  # Save checkpoint before each step
  checkpoint = create_checkpoint(step, dev_agent.context)
  save_checkpoint(db, checkpoint)
  
  step_context = focus_context_for_step(step, dev_agent.context)
  
  CASE step OF
    1: # Write tests first
       tests_result = dev_agent.write_tests_first(specs)
       track_mri(db, "test_creation", tests_result.files_accessed)
       
    2: # Prototype + minimal implementation  
       prototype_workspace = create_temp_workspace()
       prototype = dev_agent.prototype_solution(specs, prototype_workspace)
       minimal_code = dev_agent.write_minimal_implementation(tests_result.tests, prototype)
       track_mri(db, "implementation", minimal_code.files_accessed)
       
    3: # Extend incrementally with tuning
       tuned_approach = tune_development_approach(step_context)
       extended_code = dev_agent.extend_incrementally(minimal_code, tuned_approach)
       
    4: # Verify runtime
       runtime_result = dev_agent.verify_runtime(extended_code)
       track_mri(db, "verification", runtime_result.files_accessed)
       
    5: # Evolve tests based on runtime learnings
       evolved_tests = dev_agent.evolve_tests(runtime_result, tests_result.tests)
       
    6: # Re-verify with evolved tests
       reverify_result = dev_agent.reverify_runtime(evolved_tests)
       
    7: # Quality gates + validation
       quality_result = dev_agent.check_quality_gates()
       validation_result = validate_against_specs(quality_result, specs)
       
    8: # Loop decision or completion
       completion_assessment = dev_agent.assess_completion(validation_result)
       IF completion_assessment.complete THEN
         feature_complete = true
         BREAK
       ELSE
         # Continue to next iteration
         performance_profile = profile_current_cycle()
         optimize_next_iteration(performance_profile)
       END
       
    9: # NEW: Generate low-level algorithm from implemented code
       IF feature_complete THEN
         implemented_code = scan_implemented_files()
         low_level_algorithm = generate_algorithm_from_code(implemented_code)
         save_algorithm(".vibe/algorithms/low-level/", low_level_algorithm)
       END
  END
  
  # Context management
  IF dev_agent.context_approaching_limit() THEN
    EXECUTE session_mgmt_algorithm(checkpoint, step)
    BREAK  # Will be resumed by session-mgmt.md
  END
  
  update_session_state(db, {step: step, status: "in_progress"})
END

# Final cleanup and archival
IF feature_complete THEN
  merge_prototype_to_production(prototype_workspace)
  trigger_flush_protocol()
  session_update = {
    stage: "development",
    status: "completed", 
    artifacts: {
      code_files: implemented_code,
      test_files: evolved_tests,
      low_level_algorithm: low_level_algorithm
    }
  }
ELSE
  session_update = {
    stage: "development",
    status: "in_progress",
    current_step: step,
    checkpoint_id: checkpoint.id
  }
END

OUTPUT: session_update, implemented_code, low_level_algorithm