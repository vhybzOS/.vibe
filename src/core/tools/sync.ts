import { Effect, pipe } from 'effect'
import { readFile, writeFile, mkdir } from 'node:fs/promises'
import { dirname, resolve } from 'node:path'
import { match } from 'ts-pattern'
import { 
  AIToolType, 
  ToolSyncResult, 
  DetectedTool 
} from '../../schemas/ai-tool-config.js'
import { UniversalRule } from '../../schemas/universal-rule.js'
import { TOOL_CONFIGS } from './detection.js'

export const syncToolConfigs = (
  projectPath: string, 
  detectedTools: DetectedTool[], 
  rules: UniversalRule[]
) =>
  pipe(
    Effect.all(
      detectedTools.map(tool => 
        syncToolConfig(projectPath, tool.tool, rules)
      )
    ),
    Effect.map(results => ({
      timestamp: new Date().toISOString(),
      results,
      summary: {
        total: results.length,
        successful: results.filter(r => r.action !== 'error').length,
        failed: results.filter(r => r.action === 'error').length,
      },
    }))
  )

const syncToolConfig = (
  projectPath: string, 
  tool: AIToolType, 
  rules: UniversalRule[]
) =>
  pipe(
    Effect.sync(() => TOOL_CONFIGS[tool]),
    Effect.flatMap(config => {
      const relevantRules = rules.filter(rule => 
        rule.compatibility.tools.includes(tool) ||
        rule.compatibility.tools.length === 0 // Universal rules
      )
      
      return pipe(
        Effect.all(
          config.configFiles.map(configFile => 
            generateToolConfig(projectPath, tool, configFile.path, relevantRules)
          )
        ),
        Effect.map(fileResults => ({
          tool,
          action: fileResults.some(r => r.action === 'error') ? 'error' as const : 'updated' as const,
          files: fileResults,
          timestamp: new Date().toISOString(),
          conflicts: [],
          warnings: [],
        } satisfies ToolSyncResult))
      )
    })
  )

const generateToolConfig = (
  projectPath: string,
  tool: AIToolType,
  configPath: string,
  rules: UniversalRule[]
) =>
  pipe(
    Effect.sync(() => compileRulesForTool(tool, rules)),
    Effect.flatMap(compiledContent => 
      writeToolConfig(resolve(projectPath, configPath), compiledContent)
    ),
    Effect.map(() => ({
      path: configPath,
      action: 'updated' as const,
    })),
    Effect.catchAll(error => 
      Effect.succeed({
        path: configPath,
        action: 'skipped' as const,
        error: error instanceof Error ? error.message : 'Unknown error',
      })
    )
  )

const compileRulesForTool = (tool: AIToolType, rules: UniversalRule[]): string => 
  match(tool)
    .with('cursor', () => compileCursorRules(rules))
    .with('windsurf', () => compileWindsurfRules(rules))
    .with('claude', () => compileClaudeCommands(rules))
    .with('copilot', () => compileCopilotInstructions(rules))
    .with('codeium', () => compileCodeiumInstructions(rules))
    .with('cody', () => compileCodyInstructions(rules))
    .with('tabnine', () => compileTabnineConfig(rules))
    .exhaustive()

const compileCursorRules = (rules: UniversalRule[]): string => {
  const header = '# Cursor AI Rules\n\n> Auto-generated by .vibe - DO NOT EDIT MANUALLY\n> Edit rules in .vibe/rules/ instead\n\n'
  
  const sections = rules.map(rule => {
    const content = [
      `## ${rule.metadata.name}`,
      '',
      rule.metadata.description,
      '',
      rule.content.markdown,
    ]
    
    if (rule.content.examples.length > 0) {
      content.push('', '### Examples', '')
      rule.content.examples.forEach(example => {
        content.push(`#### ${example.description}`, '')
        content.push('```' + example.language, example.code, '```', '')
      })
    }
    
    return content.join('\n')
  })
  
  return header + sections.join('\n\n---\n\n')
}

const compileWindsurfRules = (rules: UniversalRule[]): string => {
  const header = '# Windsurf AI Rules\n\n> Auto-generated by .vibe - DO NOT EDIT MANUALLY\n> Edit rules in .vibe/rules/ instead\n\n'
  
  const sections = rules.map(rule => {
    return [
      `## ${rule.metadata.name}`,
      '',
      rule.metadata.description,
      '',
      rule.content.markdown,
      '',
    ].join('\n')
  })
  
  return header + sections.join('\n')
}

const compileClaudeCommands = (rules: UniversalRule[]): string => {
  const header = '# Claude Custom Commands\n\n> Auto-generated by .vibe - DO NOT EDIT MANUALLY\n> Edit rules in .vibe/rules/ instead\n\n'
  
  const commandRules = rules.filter(rule => 
    rule.content.tags.includes('command') || 
    rule.metadata.name.toLowerCase().includes('command')
  )
  
  const sections = commandRules.map(rule => {
    return [
      `## /${rule.metadata.name.toLowerCase().replace(/\s+/g, '-')}`,
      '',
      rule.metadata.description,
      '',
      rule.content.markdown,
      '',
    ].join('\n')
  })
  
  return header + sections.join('\n')
}

const compileCopilotInstructions = (rules: UniversalRule[]): string => {
  const header = '# GitHub Copilot Instructions\n\n> Auto-generated by .vibe - DO NOT EDIT MANUALLY\n> Edit rules in .vibe/rules/ instead\n\n'
  
  const instructions = rules.map(rule => rule.content.markdown).join('\n\n')
  
  return header + instructions
}

const compileCodeiumInstructions = (rules: UniversalRule[]): string => {
  const header = '# Codeium AI Instructions\n\n> Auto-generated by .vibe - DO NOT EDIT MANUALLY\n> Edit rules in .vibe/rules/ instead\n\n'
  
  const instructions = rules.map(rule => rule.content.markdown).join('\n\n')
  
  return header + instructions
}

const compileCodyInstructions = (rules: UniversalRule[]): string => {
  const header = '# Sourcegraph Cody Instructions\n\n> Auto-generated by .vibe - DO NOT EDIT MANUALLY\n> Edit rules in .vibe/rules/ instead\n\n'
  
  const instructions = rules.map(rule => rule.content.markdown).join('\n\n')
  
  return header + instructions
}

const compileTabnineConfig = (rules: UniversalRule[]): string => {
  const config = {
    rules: rules.map(rule => ({
      name: rule.metadata.name,
      description: rule.metadata.description,
      content: rule.content.markdown,
      tags: rule.content.tags,
    })),
    generated_by: 'dotvibe',
    generated_at: new Date().toISOString(),
  }
  
  return JSON.stringify(config, null, 2)
}

const writeToolConfig = (filePath: string, content: string) =>
  pipe(
    Effect.tryPromise({
      try: () => mkdir(dirname(filePath), { recursive: true }),
      catch: () => new Error(`Failed to create directory for ${filePath}`),
    }),
    Effect.flatMap(() => 
      Effect.tryPromise({
        try: () => writeFile(filePath, content, 'utf-8'),
        catch: () => new Error(`Failed to write ${filePath}`),
      })
    )
  )

export const importToolConfig = (
  tool: AIToolType,
  configPath: string
) =>
  pipe(
    Effect.tryPromise({
      try: () => readFile(configPath, 'utf-8'),
      catch: () => new Error(`Failed to read ${configPath}`),
    }),
    Effect.flatMap(content => parseToolConfigToRules(tool, content)),
    Effect.map(rules => ({
      tool,
      importedRules: rules,
      timestamp: new Date().toISOString(),
    }))
  )

const parseToolConfigToRules = (tool: AIToolType, content: string) =>
  match(tool)
    .with('cursor', () => parseCursorRulesToUniversal(content))
    .with('windsurf', () => parseWindsurfRulesToUniversal(content))
    .with('claude', () => parseClaudeCommandsToUniversal(content))
    .with('copilot', () => parseCopilotInstructionsToUniversal(content))
    .with('codeium', () => parseCodeiumInstructionsToUniversal(content))
    .with('cody', () => parseCodyInstructionsToUniversal(content))
    .with('tabnine', () => parseTabnineConfigToUniversal(content))
    .exhaustive()

// Simplified parsers - in production, these would be more sophisticated
const parseCursorRulesToUniversal = (content: string) =>
  Effect.succeed([
    createUniversalRuleFromContent('cursor', 'Imported Cursor Rules', content)
  ])

const parseWindsurfRulesToUniversal = (content: string) =>
  Effect.succeed([
    createUniversalRuleFromContent('windsurf', 'Imported Windsurf Rules', content)
  ])

const parseClaudeCommandsToUniversal = (content: string) =>
  Effect.succeed([
    createUniversalRuleFromContent('claude', 'Imported Claude Commands', content)
  ])

const parseCopilotInstructionsToUniversal = (content: string) =>
  Effect.succeed([
    createUniversalRuleFromContent('copilot', 'Imported Copilot Instructions', content)
  ])

const parseCodeiumInstructionsToUniversal = (content: string) =>
  Effect.succeed([
    createUniversalRuleFromContent('codeium', 'Imported Codeium Instructions', content)
  ])

const parseCodyInstructionsToUniversal = (content: string) =>
  Effect.succeed([
    createUniversalRuleFromContent('cody', 'Imported Cody Instructions', content)
  ])

const parseTabnineConfigToUniversal = (content: string) =>
  pipe(
    Effect.try({
      try: () => JSON.parse(content),
      catch: () => new Error('Invalid Tabnine config JSON'),
    }),
    Effect.map(config => [
      createUniversalRuleFromContent('tabnine', 'Imported Tabnine Config', JSON.stringify(config, null, 2))
    ])
  )

const createUniversalRuleFromContent = (
  tool: AIToolType,
  name: string,
  content: string
): UniversalRule => ({
  id: crypto.randomUUID(),
  metadata: {
    name,
    description: `Imported from ${tool} configuration`,
    source: 'tool-sync',
    confidence: 0.8,
    created: new Date().toISOString(),
    updated: new Date().toISOString(),
    version: '1.0.0',
  },
  targeting: {
    languages: [],
    frameworks: [],
    files: [],
    contexts: [],
  },
  content: {
    markdown: content,
    examples: [],
    tags: ['imported', tool],
    priority: 'medium',
  },
  compatibility: {
    tools: [tool],
    formats: {},
  },
  application: {
    mode: 'always',
    conditions: [],
    excludeFiles: [],
    includeFiles: [],
  },
  generated: {
    auto: false,
    fromTool: tool,
    confidence: 0.8,
    reviewRequired: true,
  },
})