# .vibe - Product Requirements Document

## Active Task and Thread(s)

_No active work - all major features completed. Ready for next planning phase._

Use [planning mode protocol](PROTOCOLS.md#planning-mode-protocol) to define next user flow.

---

## Planned Features

### Phase 2: Enhanced Command Interface

**Delivering Blog Article Promises:**

- `vibe code hono --list` - List available capability patterns
- `vibe code hono middleware` - Show capability-specific documentation
- `vibe code --map zod zod/v4` - Version-specific AI context mapping

**Technical Requirements:**

- LLM-powered capability extraction from documentation
- Enhanced TOML index with capability tracking
- Pattern storage in capability-specific .md files

### Phase 3: Automatic Intelligence & File Watching

- Monitor `package.json`/`deno.json` for changes
- Automatic documentation fetching for new dependencies
- Version change detection and cache updates
- Background capability extraction with confidence scoring

### Phase 4: Universal Access via MCP Integration

- Dynamic MCP tool generation from cached capabilities
- Same functionality in ChatGPT, Claude Desktop, Cursor
- Cross-platform integration with consistent interface
- Repository intelligence for clone-and-go tool availability

### Phase 5: Advanced Features & Quality of Life

- Enhanced CLI commands (`vibe status`, `vibe sync`, `vibe extract`)
- Performance optimization and cache validation
- Migration tools and developer experience improvements

---

## Product Vision

Transform every dependency in your project into instantly-available tools across all AI environments. Solve IDE fragmentation by making your entire development toolkit accessible in Cursor, ChatGPT, Claude, and any MCP-compatible AI.

### The "Vibe Coding" Philosophy

Based on our blog article "Vibe code in production and don't listen to haters!", .vibe enables a new development paradigm:

- **Passion Coding**: The 5% of elegant, creative code you love to write
- **Vibe Coding**: The 95% where you become a demanding architect, setting vision while AI handles implementation
- **Corporate Jujitsu**: Using TDD, documentation standards, and other "corporate BS" as tools to control AI agents

**Key Promise**: Developers become "Karens" who define the architectural vision while robots handle the boring implementation work.

### Core Problem & Solution

**Problem**: AI IDE fragmentation traps project knowledge in specific tools, forcing constant context switching.

**Solution**: "Empowering coach lurking in the shadows" - minimal-touch automation that:

1. **Observes** project dependencies automatically
2. **Extracts** developer tools from each library
3. **Exposes** tools universally via MCP protocol
4. **Enables** seamless AI assistance across all environments

### Success Definition

**Phase 1 Success**: ✅ A developer can run `vibe code <package>` for any dependency in their project and get fresh, authoritative documentation printed to stdout, with intelligent caching for fast subsequent access.

**Long-term Success**: A developer can `vibe init` in any project and have their entire development toolkit available across all AI environments with zero maintenance overhead.

### Project Structure

```
user-project/
├── .vibe/
│   ├── config.json                # Project configuration
│   ├── libraries/                 # Library documentation cache
│   │   ├── index.toml            # Fast lookup: package → version + domain
│   │   └── docs/{package}/       # Per-package documentation folders
│   ├── rules/                    # Rule definitions
│   └── generated/                # Generated file tracking
├── package.json / deno.json      # Dependencies we scan
├── AGENTS.md                     # Generated by URE
└── CLAUDE.md                     # Enhanced with library access
```

### Technical Constraints

- **Deno-native**: No Node.js dependencies, use @std/toml for parsing
- **Effect-TS**: Functional composition, type-safe errors throughout
- **File-Based**: Local storage, no cloud dependencies
- **Merge-Safe**: Never overwrite existing implementations
