/**
 * Tool configuration synchronization
 * Handles bidirectional sync between .vibe and AI tool configs
 */

import { Effect, pipe } from 'effect'
import { dirname, resolve } from '@std/path'
import { match } from 'ts-pattern'
import { AIToolType, DetectedTool, ToolSyncResult } from '../schemas/ai-tool-config.ts'
import { UniversalRule } from '../schemas/universal-rule.ts'
import { TOOL_CONFIGS } from './detection.ts'
import { parseToolConfig } from './parsers.ts'
import { ensureDir, readTextFile, writeTextFile } from '../lib/effects.ts'
import { logWithContext, VibeError } from '../lib/effects.ts'

/**
 * Synchronizes all detected tool configurations
 */
export const syncToolConfigs = (
  projectPath: string,
  detectedTools: DetectedTool[],
  rules: UniversalRule[],
) =>
  pipe(
    Effect.all(
      detectedTools.map((tool) => syncSingleTool(projectPath, tool.tool, rules)),
    ),
    Effect.map((results) => ({
      timestamp: new Date().toISOString(),
      results,
      summary: {
        total: results.length,
        successful: results.filter((r) => r.action !== 'error').length,
        failed: results.filter((r) => r.action === 'error').length,
      },
    })),
    Effect.tap((summary) =>
      logWithContext(
        'Sync',
        `Completed: ${summary.summary.successful}/${summary.summary.total} tools`,
      )
    ),
  )

/**
 * Synchronizes configuration for a single tool
 */
const syncSingleTool = (
  projectPath: string,
  tool: AIToolType,
  rules: UniversalRule[],
) =>
  pipe(
    Effect.sync(() => TOOL_CONFIGS[tool]),
    Effect.flatMap((config) => {
      const relevantRules = rules.filter((rule) =>
        rule.compatibility.tools.includes(tool) ||
        rule.compatibility.tools.length === 0 // Universal rules
      )

      return pipe(
        Effect.all(
          config.configFiles.map((configFile) =>
            generateToolConfig(projectPath, tool, configFile.path, relevantRules)
          ),
        ),
        Effect.map((fileResults) => ({
          tool,
          action: fileResults.some((r) => 'error' in r) ? 'error' as const : 'updated' as const,
          files: fileResults,
          timestamp: new Date().toISOString(),
          conflicts: [],
          warnings: [],
        } satisfies ToolSyncResult)),
      )
    }),
  )

/**
 * Generates configuration file for a specific tool
 */
const generateToolConfig = (
  projectPath: string,
  tool: AIToolType,
  configPath: string,
  rules: UniversalRule[],
) =>
  pipe(
    Effect.sync(() => compileRulesForTool(tool, rules)),
    Effect.flatMap((compiledContent) =>
      writeToolConfig(resolve(projectPath, configPath), compiledContent)
    ),
    Effect.map(() => ({
      path: configPath,
      action: 'updated' as const,
    })),
    Effect.catchAll((error) =>
      Effect.succeed({
        path: configPath,
        action: 'skipped' as const,
        error: error instanceof Error ? error.message : 'Unknown error',
      })
    ),
  )

/**
 * Compiles Universal Rules into tool-specific format
 */
const compileRulesForTool = (tool: AIToolType, rules: UniversalRule[]): string =>
  match(tool)
    .with('cursor', () => compileCursorRules(rules))
    .with('windsurf', () => compileWindsurfRules(rules))
    .with('claude', () => compileClaudeCommands(rules))
    .with('copilot', () => compileCopilotInstructions(rules))
    .with('codeium', () => compileCodeiumInstructions(rules))
    .with('cody', () => compileCodyInstructions(rules))
    .with('tabnine', () => compileTabnineConfig(rules))
    .exhaustive()

/**
 * Compiles rules for Cursor (.cursorrules)
 */
const compileCursorRules = (rules: UniversalRule[]): string => {
  const header =
    '# Cursor AI Rules\n\n> Auto-generated by .vibe - DO NOT EDIT MANUALLY\n> Edit rules in .vibe/rules/ instead\n\n'

  const sections = rules.map((rule) => {
    const content = [
      `## ${rule.metadata.name}`,
      '',
      rule.metadata.description,
      '',
      rule.content.markdown,
    ]

    if (rule.content.examples.length > 0) {
      content.push('', '### Examples', '')
      rule.content.examples.forEach((example) => {
        content.push(`#### ${example.description}`, '')
        content.push('```' + example.language, example.code, '```', '')
      })
    }

    return content.join('\n')
  })

  return header + sections.join('\n\n---\n\n')
}

/**
 * Compiles rules for Windsurf (.windsurfrules)
 */
const compileWindsurfRules = (rules: UniversalRule[]): string => {
  const header =
    '# Windsurf AI Rules\n\n> Auto-generated by .vibe - DO NOT EDIT MANUALLY\n> Edit rules in .vibe/rules/ instead\n\n'

  const sections = rules.map((rule) =>
    [
      `## ${rule.metadata.name}`,
      '',
      rule.metadata.description,
      '',
      rule.content.markdown,
      '',
    ].join('\n')
  )

  return header + sections.join('\n')
}

/**
 * Compiles rules for Claude (.claude/commands.md)
 */
const compileClaudeCommands = (rules: UniversalRule[]): string => {
  const header =
    '# Claude Custom Commands\n\n> Auto-generated by .vibe - DO NOT EDIT MANUALLY\n> Edit rules in .vibe/rules/ instead\n\n'

  const commandRules = rules.filter((rule) =>
    rule.content.tags.includes('command') ||
    rule.metadata.name.toLowerCase().includes('command')
  )

  const sections = commandRules.map((rule) =>
    [
      `## /${rule.metadata.name.toLowerCase().replace(/\s+/g, '-')}`,
      '',
      rule.metadata.description,
      '',
      rule.content.markdown,
      '',
    ].join('\n')
  )

  return header + sections.join('\n')
}

/**
 * Compiles rules for GitHub Copilot
 */
const compileCopilotInstructions = (rules: UniversalRule[]): string => {
  const header =
    '# GitHub Copilot Instructions\n\n> Auto-generated by .vibe - DO NOT EDIT MANUALLY\n> Edit rules in .vibe/rules/ instead\n\n'

  const instructions = rules.map((rule) => rule.content.markdown).join('\n\n')

  return header + instructions
}

/**
 * Compiles rules for Codeium
 */
const compileCodeiumInstructions = (rules: UniversalRule[]): string => {
  const header =
    '# Codeium AI Instructions\n\n> Auto-generated by .vibe - DO NOT EDIT MANUALLY\n> Edit rules in .vibe/rules/ instead\n\n'

  const instructions = rules.map((rule) => rule.content.markdown).join('\n\n')

  return header + instructions
}

/**
 * Compiles rules for Sourcegraph Cody
 */
const compileCodyInstructions = (rules: UniversalRule[]): string => {
  const header =
    '# Sourcegraph Cody Instructions\n\n> Auto-generated by .vibe - DO NOT EDIT MANUALLY\n> Edit rules in .vibe/rules/ instead\n\n'

  const instructions = rules.map((rule) => rule.content.markdown).join('\n\n')

  return header + instructions
}

/**
 * Compiles rules for Tabnine (JSON format)
 */
const compileTabnineConfig = (rules: UniversalRule[]): string => {
  const config = {
    rules: rules.map((rule) => ({
      name: rule.metadata.name,
      description: rule.metadata.description,
      content: rule.content.markdown,
      tags: rule.content.tags,
    })),
    generated_by: 'dotvibe',
    generated_at: new Date().toISOString(),
  }

  return JSON.stringify(config, null, 2)
}

/**
 * Writes tool configuration to file
 */
const writeToolConfig = (filePath: string, content: string) =>
  pipe(
    ensureDir(dirname(filePath)),
    Effect.flatMap(() => writeTextFile(filePath, content)),
    Effect.tap(() => logWithContext('Sync', `Written ${filePath}`)),
  )

/**
 * Imports tool configuration and converts to Universal Rules
 */
export const importToolConfig = (
  tool: AIToolType,
  configPath: string,
) =>
  pipe(
    readTextFile(configPath),
    Effect.flatMap((content) => parseToolConfig(tool, content)),
    Effect.map((rules) => ({
      tool,
      importedRules: rules,
      timestamp: new Date().toISOString(),
    })),
    Effect.tap((result) =>
      logWithContext('Import', `Imported ${result.importedRules.length} rules from ${tool}`)
    ),
  )
