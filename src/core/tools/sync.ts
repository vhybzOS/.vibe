import { Effect, pipe } from 'effect'
import { dirname, resolve } from '@std/path'
import { match } from 'ts-pattern'
import { 
  AIToolType, 
  ToolSyncResult, 
  DetectedTool 
} from '../../schemas/ai-tool-config.ts'
import { UniversalRule } from '../../schemas/universal-rule.ts'
import { TOOL_CONFIGS } from './detection.ts'
import { parseCursorRulesToUniversal } from './parsers/cursor.ts'
import { parseWindsurfRulesToUniversal } from './parsers/windsurf.ts'
import { parseClaudeCommandsToUniversal } from './parsers/claude.ts'

export const syncToolConfigs = (
  projectPath: string, 
  detectedTools: DetectedTool[], 
  rules: UniversalRule[]
) =>
  pipe(
    Effect.all(
      detectedTools.map(tool => 
        syncToolConfig(projectPath, tool.tool, rules)
      )
    ),
    Effect.map(results => ({
      timestamp: new Date().toISOString(),
      results,
      summary: {
        total: results.length,
        successful: results.filter(r => r.action !== 'error').length,
        failed: results.filter(r => r.action === 'error').length,
      },
    }))
  )

const syncToolConfig = (
  projectPath: string, 
  tool: AIToolType, 
  rules: UniversalRule[]
) =>
  pipe(
    Effect.sync(() => TOOL_CONFIGS[tool]),
    Effect.flatMap(config => {
      const relevantRules = rules.filter(rule => 
        rule.compatibility.tools.includes(tool) ||
        rule.compatibility.tools.length === 0 // Universal rules
      )
      
      return pipe(
        Effect.all(
          config.configFiles.map(configFile => 
            generateToolConfig(projectPath, tool, configFile.path, relevantRules)
          )
        ),
        Effect.map(fileResults => ({
          tool,
          action: fileResults.some(r => r.action === 'error') ? 'error' as const : 'updated' as const,
          files: fileResults,
          timestamp: new Date().toISOString(),
          conflicts: [],
          warnings: [],
        } satisfies ToolSyncResult))
      )
    })
  )

const generateToolConfig = (
  projectPath: string,
  tool: AIToolType,
  configPath: string,
  rules: UniversalRule[]
) =>
  pipe(
    Effect.sync(() => compileRulesForTool(tool, rules)),
    Effect.flatMap(compiledContent => 
      writeToolConfig(resolve(projectPath, configPath), compiledContent)
    ),
    Effect.map(() => ({
      path: configPath,
      action: 'updated' as const,
    })),
    Effect.catchAll(error => 
      Effect.succeed({
        path: configPath,
        action: 'skipped' as const,
        error: error instanceof Error ? error.message : 'Unknown error',
      })
    )
  )

const compileRulesForTool = (tool: AIToolType, rules: UniversalRule[]): string => 
  match(tool)
    .with('cursor', () => compileCursorRules(rules))
    .with('windsurf', () => compileWindsurfRules(rules))
    .with('claude', () => compileClaudeCommands(rules))
    .with('copilot', () => compileCopilotInstructions(rules))
    .with('codeium', () => compileCodeiumInstructions(rules))
    .with('cody', () => compileCodyInstructions(rules))
    .with('tabnine', () => compileTabnineConfig(rules))
    .exhaustive()

const compileCursorRules = (rules: UniversalRule[]): string => {
  const header = '# Cursor AI Rules\n\n> Auto-generated by .vibe - DO NOT EDIT MANUALLY\n> Edit rules in .vibe/rules/ instead\n\n'
  
  const sections = rules.map(rule => {
    const content = [
      `## ${rule.metadata.name}`,
      '',
      rule.metadata.description,
      '',
      rule.content.markdown,
    ]
    
    if (rule.content.examples.length > 0) {
      content.push('', '### Examples', '')
      rule.content.examples.forEach(example => {
        content.push(`#### ${example.description}`, '')
        content.push('```' + example.language, example.code, '```', '')
      })
    }
    
    return content.join('\n')
  })
  
  return header + sections.join('\n\n---\n\n')
}

const compileWindsurfRules = (rules: UniversalRule[]): string => {
  const header = '# Windsurf AI Rules\n\n> Auto-generated by .vibe - DO NOT EDIT MANUALLY\n> Edit rules in .vibe/rules/ instead\n\n'
  
  const sections = rules.map(rule => {
    return [
      `## ${rule.metadata.name}`,
      '',
      rule.metadata.description,
      '',
      rule.content.markdown,
      '',
    ].join('\n')
  })
  
  return header + sections.join('\n')
}

const compileClaudeCommands = (rules: UniversalRule[]): string => {
  const header = '# Claude Custom Commands\n\n> Auto-generated by .vibe - DO NOT EDIT MANUALLY\n> Edit rules in .vibe/rules/ instead\n\n'
  
  const commandRules = rules.filter(rule => 
    rule.content.tags.includes('command') || 
    rule.metadata.name.toLowerCase().includes('command')
  )
  
  const sections = commandRules.map(rule => {
    return [
      `## /${rule.metadata.name.toLowerCase().replace(/\s+/g, '-')}`,
      '',
      rule.metadata.description,
      '',
      rule.content.markdown,
      '',
    ].join('\n')
  })
  
  return header + sections.join('\n')
}

const compileCopilotInstructions = (rules: UniversalRule[]): string => {
  const header = '# GitHub Copilot Instructions\n\n> Auto-generated by .vibe - DO NOT EDIT MANUALLY\n> Edit rules in .vibe/rules/ instead\n\n'
  
  const instructions = rules.map(rule => rule.content.markdown).join('\n\n')
  
  return header + instructions
}

const compileCodeiumInstructions = (rules: UniversalRule[]): string => {
  const header = '# Codeium AI Instructions\n\n> Auto-generated by .vibe - DO NOT EDIT MANUALLY\n> Edit rules in .vibe/rules/ instead\n\n'
  
  const instructions = rules.map(rule => rule.content.markdown).join('\n\n')
  
  return header + instructions
}

const compileCodyInstructions = (rules: UniversalRule[]): string => {
  const header = '# Sourcegraph Cody Instructions\n\n> Auto-generated by .vibe - DO NOT EDIT MANUALLY\n> Edit rules in .vibe/rules/ instead\n\n'
  
  const instructions = rules.map(rule => rule.content.markdown).join('\n\n')
  
  return header + instructions
}

const compileTabnineConfig = (rules: UniversalRule[]): string => {
  const config = {
    rules: rules.map(rule => ({
      name: rule.metadata.name,
      description: rule.metadata.description,
      content: rule.content.markdown,
      tags: rule.content.tags,
    })),
    generated_by: 'dotvibe',
    generated_at: new Date().toISOString(),
  }
  
  return JSON.stringify(config, null, 2)
}

/**
 * Writes tool configuration to file using Deno APIs
 * 
 * @param filePath - Path to write the file
 * @param content - File content
 * @returns Effect that completes when file is written
 */
const writeToolConfig = (filePath: string, content: string) =>
  pipe(
    Effect.tryPromise({
      try: () => Deno.mkdir(dirname(filePath), { recursive: true }),
      catch: () => new Error(`Failed to create directory for ${filePath}`),
    }),
    Effect.flatMap(() => 
      Effect.tryPromise({
        try: () => Deno.writeTextFile(filePath, content),
        catch: () => new Error(`Failed to write ${filePath}`),
      })
    )
  )

/**
 * Imports tool configuration and converts it to Universal Rules
 * 
 * @param tool - AI tool type
 * @param configPath - Path to the config file
 * @returns Effect that resolves to imported rules
 */
export const importToolConfig = (
  tool: AIToolType,
  configPath: string
) =>
  pipe(
    Effect.tryPromise({
      try: () => Deno.readTextFile(configPath),
      catch: () => new Error(`Failed to read ${configPath}`),
    }),
    Effect.flatMap(content => parseToolConfigToRules(tool, content)),
    Effect.map(rules => ({
      tool,
      importedRules: rules,
      timestamp: new Date().toISOString(),
    }))
  )

/**
 * Parses tool-specific configuration content into Universal Rules
 * Uses specialized parsers for each tool type
 * 
 * @param tool - AI tool type
 * @param content - Configuration file content
 * @returns Effect that resolves to array of Universal Rules
 */
const parseToolConfigToRules = (tool: AIToolType, content: string) =>
  match(tool)
    .with('cursor', () => parseCursorRulesToUniversal(content))
    .with('windsurf', () => parseWindsurfRulesToUniversal(content))
    .with('claude', () => parseClaudeCommandsToUniversal(content))
    .with('copilot', () => parseMarkdownInstructionsToUniversal(content, 'copilot'))
    .with('codeium', () => parseMarkdownInstructionsToUniversal(content, 'codeium'))
    .with('cody', () => parseMarkdownInstructionsToUniversal(content, 'cody'))
    .with('tabnine', () => parseTabnineConfigToUniversal(content))
    .exhaustive()

/**
 * Generic parser for markdown-based instructions (used by tools without specialized parsers)
 * 
 * @param content - Markdown content
 * @param toolName - Name of the tool
 * @returns Effect that resolves to array of Universal Rules
 */
const parseMarkdownInstructionsToUniversal = (content: string, toolName: string) =>
  Effect.succeed([
    createUniversalRuleFromContent(toolName as AIToolType, `Imported ${toolName} Instructions`, content)
  ])

/**
 * Parses Tabnine JSON configuration
 * 
 * @param content - JSON content
 * @returns Effect that resolves to array of Universal Rules
 */
const parseTabnineConfigToUniversal = (content: string) =>
  pipe(
    Effect.try({
      try: () => JSON.parse(content),
      catch: () => new Error('Invalid Tabnine config JSON'),
    }),
    Effect.map(config => [
      createUniversalRuleFromContent('tabnine', 'Imported Tabnine Config', JSON.stringify(config, null, 2))
    ])
  )

/**
 * Creates a Universal Rule from imported tool content
 * Used as fallback for tools without specialized parsers
 * 
 * @param tool - AI tool type
 * @param name - Rule name
 * @param content - Rule content
 * @returns UniversalRule object
 */
const createUniversalRuleFromContent = (
  tool: AIToolType,
  name: string,
  content: string
): UniversalRule => ({
  id: crypto.randomUUID(),
  metadata: {
    name,
    description: `Imported from ${tool} configuration`,
    source: 'tool-sync',
    confidence: 0.8,
    created: new Date().toISOString(),
    updated: new Date().toISOString(),
    version: '1.0.0',
  },
  targeting: {
    languages: [],
    frameworks: [],
    files: [],
    contexts: [],
  },
  content: {
    markdown: content,
    examples: [],
    tags: ['imported', tool],
    priority: 'medium',
  },
  compatibility: {
    tools: [tool],
    formats: {},
  },
  application: {
    mode: 'always',
    conditions: [],
    excludeFiles: [],
    includeFiles: [],
  },
  generated: {
    auto: false,
    fromTool: tool,
    confidence: 0.8,
    reviewRequired: true,
  },
})