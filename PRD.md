# .vibe - Universal Developer Tool Orchestrator

## Product Vision

Transform every dependency in your project into instantly-available tools across all AI environments. Solve IDE fragmentation by making your entire development toolkit accessible in Cursor, ChatGPT, Claude, and any MCP-compatible AI.

## Core Problem

Developers suffer from **AI IDE fragmentation**:

- Start coding in Cursor, can't continue context on ChatGPT mobile
- Each AI tool has different interfaces for the same underlying capabilities
- Project knowledge trapped in specific IDEs
- Constant context switching between development environments

## Solution Approach

**"Empowering coach lurking in the shadows"** - minimal-touch automation that:

1. **Observes** your project dependencies automatically
2. **Extracts** developer tools from each library (Hono â†’ routing tools, Zod â†’ validation tools)
3. **Exposes** these tools universally via MCP protocol
4. **Enables** seamless AI assistance across all environments

## Key Differentiators

- **Zero Configuration**: `vibe init` â†’ everything automated thereafter
- **Tool-Centric**: Libraries become discoverable, callable tools
- **Universal Access**: Same tools in Cursor, ChatGPT, Claude Desktop, etc.
- **Network Effects**: Projects with `.vibe` folders share tool intelligence
- **Non-Invasive**: No workflow disruption, no maintenance overhead

## Architecture Overview

### Our Codebase Structure

```
.vibe/                       # Our development repo
â”œâ”€â”€ ure/                     # Unified Rule Engine module (OUR CODE)
â”‚   â”œâ”€â”€ schemas/             # Zod schemas for user project structures
â”‚   â”œâ”€â”€ services/            # Core business logic services
â”‚   â”œâ”€â”€ transformers/        # IDE-specific file generators
â”‚   â”œâ”€â”€ parsers/             # TOML/content parsing (@std/toml)
â”‚   â”œâ”€â”€ watcher/             # File watching system
â”‚   â”œâ”€â”€ lib/                 # Effect-TS utilities (from legacy)
â”‚   â””â”€â”€ index.ts             # Main URE orchestrator
â”œâ”€â”€ templates/               # Generation templates (OUR TEMPLATES)
â”‚   â”œâ”€â”€ agents.md.hbs        # Handlebars template for AGENTS.md
â”‚   â”œâ”€â”€ claude.md.hbs        # Handlebars template for CLAUDE.md
â”‚   â”œâ”€â”€ cursor/              # Cursor .mdc templates
â”‚   â””â”€â”€ windsurf/            # Windsurf .mdc templates
```

### User Project Structure (Created by `vibe init`)

```
their-project/
â”œâ”€â”€ .vibe/                   # Created by our tool (THEIR DATA)
â”‚   â”œâ”€â”€ config.json         # Project configuration
â”‚   â”œâ”€â”€ rules/              # Rule definitions (TOML + .md)
â”‚   â”œâ”€â”€ dependencies/       # Dependency docs (TOML + .md)
â”‚   â””â”€â”€ generated/          # Generated file tracking
â”œâ”€â”€ AGENTS.md              # Generated by our URE (committed)
â”œâ”€â”€ CLAUDE.md              # Generated by our URE (committed)
â”œâ”€â”€ .cursor/rules/*.mdc    # Generated by our URE (git-ignored)
â”œâ”€â”€ .windsurf/rules/*.mdc  # Generated by our URE (git-ignored)
â””â”€â”€ .claude/commands/*.md  # Generated by our URE (git-ignored)
```

## Validated Requirements

### Core User Stories

1. **As a developer**, I want my project's capabilities available in any AI environment
2. **As a mobile coder**, I want to continue Cursor work seamlessly in ChatGPT mobile
3. **As a team member**, I want instant access to project tools when I clone a repo
4. **As a productivity-focused dev**, I want zero-maintenance tool orchestration

### Feature Priorities

#### âœ… P0: Foundation + IDE Integration (Current Active)

**URE System:**

- **URE Module** (`ure/` in our codebase): Complete engine for processing user .vibe/ data
- **TOML Indexes**: Fast metadata lookup using @std/toml in user .vibe/ folders
- **Rule Management**: TOML index + .md content files for user-editable rules
- **Templates Module** (`templates/` in our codebase): Handlebars generators for all IDE formats
- **File Generation**: Our templates + user data â†’ user IDE files
- **File Watching**: Our daemon monitors user .vibe/ changes

**IDE Support:**

- **Cursor Support**: Generate `.cursor/rules/*.mdc` with YAML frontmatter + content
- **Windsurf Support**: Generate `.windsurf/rules/*.mdc` with similar MDC format
- **Claude Code Support**: Generate `CLAUDE.md` (committed) + optional `CLAUDE.local.md`
- **Gitignore Management**: Auto-add IDE-specific paths (`.cursor/`, `.windsurf/`, `.claude/`)

**Dependency Discovery:**

- **Manifest Detection**: package.json/deno.json parsing
- **llms.txt Fetching**: HTTP client for dependency documentation
- **Simple Storage**: Copy llms.txt â†’ .vibe/dependencies/docs/name.md

#### ðŸ“… P1: Enhanced Tool Intelligence (Future)

- **LLM Integration**: Fine-grained tool extraction from dependencies using user API keys
- **Per-Dependency Folders**: `.vibe/dependencies/hono/` structure with tools/ subdirectories
- **Tool Extraction**: LLM-powered capability analysis (e.g., Hono â†’ routing, middleware, validation tools)
- **Dynamic MCP Exposure**: Basic (single tool) vs Pro (multiple tools) per dependency
- **`vibe code` Command**: LLM-friendly dependency documentation access during coding

#### ðŸ“… P2: Universal Access (Future)

- **Claude Commands**: Generate `.claude/commands/*.md` for slash commands
- **MCP Server Enhancement**: Dynamic tool loading based on extraction level
- **Cross-Platform**: Multiple AI environment integration across Cursor, ChatGPT, Claude Desktop
- **Repository Intelligence**: Clone-and-go tool availability

#### ðŸ“… P3: Quality of Life (Future)

- **Enhanced CLI**: `vibe extract`, `vibe status`, `vibe sync` commands
- **Migration Tools**: Convert existing configs to URE format
- **Performance Optimization**: Caching, incremental updates, confidence scoring
- **Error Recovery**: Graceful handling of edge cases

## IDE File Format Specifications

### Cursor (.cursor/rules/*.mdc)

- **Format**: YAML frontmatter + Markdown content
- **Metadata**: description, globs, triggers, alwaysApply, priority
- **Features**: Nested rules, file references via `@filename.ext`
- **Priority**: Filename ordering and YAML metadata controls priority

### Windsurf (.windsurf/rules/*.mdc)

- **Format**: Similar MDC format to Cursor
- **Integration**: Compatible with Ruler bootstrapping tools
- **Application**: Rules apply when Windsurf agent runs

### Claude Code (CLAUDE.md + .claude/commands/*.md)

- **Format**: Free-form Markdown for style guidelines, context, tool descriptions
- **Commands**: Supports `.claude/commands/*.md` for slash commands in CLI
- **Flexibility**: `CLAUDE.local.md` (git-ignored) and subdirectory support

## Technical Implementation

### TOML + Markdown Hybrid System

- **Metadata**: TOML indexes for O(1) lookups (`@std/toml`)
- **Content**: Markdown files for human-readable documentation
- **Performance**: Fast metadata access with rich content editing

### Single Source of Truth Strategy

- **User edits**: `.vibe/rules/content/code-style.md` (human-readable)
- **Our URE generates**: All IDE-specific formats from single source
- **Automatic Sync**: File watcher detects changes â†’ regenerates all IDE files
- **No manual intervention**: Consistent rules across all AI environments

### `vibe code` Command Design (P1 Future Feature)

**User Story**: As an LLM implementing code, I want to quickly access current dependency documentation and capabilities so that I can use up-to-date library information instead of outdated training data.

**Technical Specification**:

```typescript
// CLI signature
vibe code <dependency-name> [--format=json|markdown] [--capabilities]

// Examples
vibe code hono                    # Returns README.md (llms.txt copy)
vibe code hono --capabilities     # Returns capabilities list (if Tool Intelligence enabled)
vibe code effect --format=json   # Returns structured JSON format
```

**Implementation Architecture**:

```
ure/services/
â”œâ”€â”€ dependency-resolver.ts    # Resolve dependency name to registry/version
â”œâ”€â”€ documentation-fetcher.ts  # Fetch llms.txt on-demand (shared with watcher)
â”œâ”€â”€ capability-extractor.ts   # LLM-powered capability extraction (P1)
â””â”€â”€ code-command.ts          # CLI command implementation

cli/commands/
â””â”€â”€ code.ts                  # CLI entry point for `vibe code`
```

**Data Flow**:

```
vibe code hono
    â†“
1. Check if dependency exists in .vibe/dependencies/
2. If not, trigger dependency-resolver + documentation-fetcher
3. Return content from .vibe/dependencies/docs/hono.md
4. If --capabilities flag + Tool Intelligence enabled:
   - Check .vibe/dependencies/hono/tools/index.toml
   - Return capability list
```

**Design Principles for Current Implementation**:

- **Shared Services**: `documentation-fetcher.ts` used by both file watcher and `vibe code` command
- **Reusable Parsers**: TOML parser and dependency schemas support both automated and manual scenarios
- **API Design**: Services designed for both background automation and on-demand CLI usage

### Legacy Code Integration

- **Direct Copy**: `legacy/lib/{effects,errors,fs}.ts` â†’ `ure/lib/`
- **Adaptation**: File watcher, dependency detection, project schemas
- **Reference**: Universal rule patterns, sync mechanisms

## Success Metrics

- **Adoption**: Projects using `.vibe` folders
- **Tool Coverage**: Percentage of dependencies with extracted tools
- **Cross-Platform Usage**: Same tools used across multiple AI environments
- **Developer Velocity**: Reduced context switching, faster tool discovery
- **IDE Integration**: Seamless rule sync across Cursor, Windsurf, Claude Code

## Technical Constraints

- **Deno-native**: No Node.js dependencies, use @std/toml for parsing
- **Effect-TS**: Functional composition, type-safe errors throughout URE
- **File-Based**: Local storage, no cloud dependencies
- **Zero Config**: Autonomous operation after `vibe init`
- **Universal Compatibility**: Support for all major AI IDE formats

## Success Definition

A developer can `vibe init` in any project, edit rules in `.vibe/rules/content/`, and immediately have those rules available in consistent formats across Cursor, Windsurf, Claude Code, and any future AI environment, with automatic sync and zero maintenance overhead.
